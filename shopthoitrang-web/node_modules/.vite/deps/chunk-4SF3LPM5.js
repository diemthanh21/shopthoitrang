import {
  InfoCircleFilled_default
} from "./chunk-3RVAH3MM.js";
import {
  CheckCircleFilled_default
} from "./chunk-ZP6ZMOSC.js";
import {
  ExclamationCircleFilled_default
} from "./chunk-N2F3IRVS.js";
import {
  CONTAINER_MAX_OFFSET
} from "./chunk-TL2PFZVF.js";
import {
  CloseOutlined_default
} from "./chunk-7U5TLJXA.js";
import {
  CloseCircleFilled_default
} from "./chunk-DZO4JCFN.js";
import {
  useCSSVarCls_default
} from "./chunk-FATP7YLN.js";
import {
  pickAttrs
} from "./chunk-HMVKI2QT.js";
import {
  unstableSetRender
} from "./chunk-73YGOOBX.js";
import {
  LoadingOutlined_default
} from "./chunk-D2WTFVBH.js";
import {
  KeyCode_default
} from "./chunk-K3RIWS4Z.js";
import {
  CSSMotionList_default,
  ConfigContext,
  Keyframes_default,
  _defineProperty,
  _extends,
  _objectSpread2,
  _objectWithoutProperties,
  _slicedToArray,
  _toConsumableArray,
  _typeof,
  config_provider_default,
  devUseWarning,
  genStyleHooks,
  globalConfig,
  merge2 as merge,
  require_classnames,
  resetComponent,
  useEvent,
  warnContext
} from "./chunk-4Y3TNRHT.js";
import {
  require_react_dom
} from "./chunk-NUMECXU6.js";
import {
  require_react
} from "./chunk-RLJ2RCJQ.js";
import {
  __toESM
} from "./chunk-DC5AMYBS.js";

// node_modules/antd/es/message/index.js
var import_react4 = __toESM(require_react());

// node_modules/antd/es/app/context.js
var import_react = __toESM(require_react());
var AppConfigContext = import_react.default.createContext({});
var AppContext = import_react.default.createContext({
  message: {},
  notification: {},
  modal: {}
});
var context_default = AppContext;

// node_modules/antd/es/message/PurePanel.js
var React7 = __toESM(require_react());
var import_classnames3 = __toESM(require_classnames());

// node_modules/rc-notification/es/hooks/useNotification.js
var React6 = __toESM(require_react());

// node_modules/rc-notification/es/Notifications.js
var React5 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());

// node_modules/rc-notification/es/NoticeList.js
var import_react3 = __toESM(require_react());
var import_classnames2 = __toESM(require_classnames());

// node_modules/rc-notification/es/Notice.js
var import_classnames = __toESM(require_classnames());
var React2 = __toESM(require_react());
var Notify = React2.forwardRef(function(props, ref) {
  var prefixCls = props.prefixCls, style = props.style, className = props.className, _props$duration = props.duration, duration = _props$duration === void 0 ? 4.5 : _props$duration, showProgress = props.showProgress, _props$pauseOnHover = props.pauseOnHover, pauseOnHover = _props$pauseOnHover === void 0 ? true : _props$pauseOnHover, eventKey = props.eventKey, content = props.content, closable = props.closable, _props$closeIcon = props.closeIcon, closeIcon = _props$closeIcon === void 0 ? "x" : _props$closeIcon, divProps = props.props, onClick = props.onClick, onNoticeClose = props.onNoticeClose, times = props.times, forcedHovering = props.hovering;
  var _React$useState = React2.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), hovering = _React$useState2[0], setHovering = _React$useState2[1];
  var _React$useState3 = React2.useState(0), _React$useState4 = _slicedToArray(_React$useState3, 2), percent = _React$useState4[0], setPercent = _React$useState4[1];
  var _React$useState5 = React2.useState(0), _React$useState6 = _slicedToArray(_React$useState5, 2), spentTime = _React$useState6[0], setSpentTime = _React$useState6[1];
  var mergedHovering = forcedHovering || hovering;
  var mergedShowProgress = duration > 0 && showProgress;
  var onInternalClose = function onInternalClose2() {
    onNoticeClose(eventKey);
  };
  var onCloseKeyDown = function onCloseKeyDown2(e) {
    if (e.key === "Enter" || e.code === "Enter" || e.keyCode === KeyCode_default.ENTER) {
      onInternalClose();
    }
  };
  React2.useEffect(function() {
    if (!mergedHovering && duration > 0) {
      var start = Date.now() - spentTime;
      var timeout = setTimeout(function() {
        onInternalClose();
      }, duration * 1e3 - spentTime);
      return function() {
        if (pauseOnHover) {
          clearTimeout(timeout);
        }
        setSpentTime(Date.now() - start);
      };
    }
  }, [duration, mergedHovering, times]);
  React2.useEffect(function() {
    if (!mergedHovering && mergedShowProgress && (pauseOnHover || spentTime === 0)) {
      var start = performance.now();
      var animationFrame;
      var calculate = function calculate2() {
        cancelAnimationFrame(animationFrame);
        animationFrame = requestAnimationFrame(function(timestamp) {
          var runtime = timestamp + spentTime - start;
          var progress = Math.min(runtime / (duration * 1e3), 1);
          setPercent(progress * 100);
          if (progress < 1) {
            calculate2();
          }
        });
      };
      calculate();
      return function() {
        if (pauseOnHover) {
          cancelAnimationFrame(animationFrame);
        }
      };
    }
  }, [duration, spentTime, mergedHovering, mergedShowProgress, times]);
  var closableObj = React2.useMemo(function() {
    if (_typeof(closable) === "object" && closable !== null) {
      return closable;
    }
    if (closable) {
      return {
        closeIcon
      };
    }
    return {};
  }, [closable, closeIcon]);
  var ariaProps = pickAttrs(closableObj, true);
  var validPercent = 100 - (!percent || percent < 0 ? 0 : percent > 100 ? 100 : percent);
  var noticePrefixCls = "".concat(prefixCls, "-notice");
  return React2.createElement("div", _extends({}, divProps, {
    ref,
    className: (0, import_classnames.default)(noticePrefixCls, className, _defineProperty({}, "".concat(noticePrefixCls, "-closable"), closable)),
    style,
    onMouseEnter: function onMouseEnter(e) {
      var _divProps$onMouseEnte;
      setHovering(true);
      divProps === null || divProps === void 0 || (_divProps$onMouseEnte = divProps.onMouseEnter) === null || _divProps$onMouseEnte === void 0 || _divProps$onMouseEnte.call(divProps, e);
    },
    onMouseLeave: function onMouseLeave(e) {
      var _divProps$onMouseLeav;
      setHovering(false);
      divProps === null || divProps === void 0 || (_divProps$onMouseLeav = divProps.onMouseLeave) === null || _divProps$onMouseLeav === void 0 || _divProps$onMouseLeav.call(divProps, e);
    },
    onClick
  }), React2.createElement("div", {
    className: "".concat(noticePrefixCls, "-content")
  }, content), closable && React2.createElement("a", _extends({
    tabIndex: 0,
    className: "".concat(noticePrefixCls, "-close"),
    onKeyDown: onCloseKeyDown,
    "aria-label": "Close"
  }, ariaProps, {
    onClick: function onClick2(e) {
      e.preventDefault();
      e.stopPropagation();
      onInternalClose();
    }
  }), closableObj.closeIcon), mergedShowProgress && React2.createElement("progress", {
    className: "".concat(noticePrefixCls, "-progress"),
    max: "100",
    value: validPercent
  }, validPercent + "%"));
});
var Notice_default = Notify;

// node_modules/rc-notification/es/NotificationProvider.js
var import_react2 = __toESM(require_react());
var NotificationContext = import_react2.default.createContext({});
var NotificationProvider = function NotificationProvider2(_ref) {
  var children = _ref.children, classNames4 = _ref.classNames;
  return import_react2.default.createElement(NotificationContext.Provider, {
    value: {
      classNames: classNames4
    }
  }, children);
};
var NotificationProvider_default = NotificationProvider;

// node_modules/rc-notification/es/hooks/useStack.js
var DEFAULT_OFFSET = 8;
var DEFAULT_THRESHOLD = 3;
var DEFAULT_GAP = 16;
var useStack = function useStack2(config) {
  var result = {
    offset: DEFAULT_OFFSET,
    threshold: DEFAULT_THRESHOLD,
    gap: DEFAULT_GAP
  };
  if (config && _typeof(config) === "object") {
    var _config$offset, _config$threshold, _config$gap;
    result.offset = (_config$offset = config.offset) !== null && _config$offset !== void 0 ? _config$offset : DEFAULT_OFFSET;
    result.threshold = (_config$threshold = config.threshold) !== null && _config$threshold !== void 0 ? _config$threshold : DEFAULT_THRESHOLD;
    result.gap = (_config$gap = config.gap) !== null && _config$gap !== void 0 ? _config$gap : DEFAULT_GAP;
  }
  return [!!config, result];
};
var useStack_default = useStack;

// node_modules/rc-notification/es/NoticeList.js
var _excluded = ["className", "style", "classNames", "styles"];
var NoticeList = function NoticeList2(props) {
  var configList = props.configList, placement = props.placement, prefixCls = props.prefixCls, className = props.className, style = props.style, motion = props.motion, onAllNoticeRemoved = props.onAllNoticeRemoved, onNoticeClose = props.onNoticeClose, stackConfig = props.stack;
  var _useContext = (0, import_react3.useContext)(NotificationContext), ctxCls = _useContext.classNames;
  var dictRef = (0, import_react3.useRef)({});
  var _useState = (0, import_react3.useState)(null), _useState2 = _slicedToArray(_useState, 2), latestNotice = _useState2[0], setLatestNotice = _useState2[1];
  var _useState3 = (0, import_react3.useState)([]), _useState4 = _slicedToArray(_useState3, 2), hoverKeys = _useState4[0], setHoverKeys = _useState4[1];
  var keys = configList.map(function(config) {
    return {
      config,
      key: String(config.key)
    };
  });
  var _useStack = useStack_default(stackConfig), _useStack2 = _slicedToArray(_useStack, 2), stack = _useStack2[0], _useStack2$ = _useStack2[1], offset = _useStack2$.offset, threshold = _useStack2$.threshold, gap = _useStack2$.gap;
  var expanded = stack && (hoverKeys.length > 0 || keys.length <= threshold);
  var placementMotion = typeof motion === "function" ? motion(placement) : motion;
  (0, import_react3.useEffect)(function() {
    if (stack && hoverKeys.length > 1) {
      setHoverKeys(function(prev) {
        return prev.filter(function(key) {
          return keys.some(function(_ref) {
            var dataKey = _ref.key;
            return key === dataKey;
          });
        });
      });
    }
  }, [hoverKeys, keys, stack]);
  (0, import_react3.useEffect)(function() {
    var _keys;
    if (stack && dictRef.current[(_keys = keys[keys.length - 1]) === null || _keys === void 0 ? void 0 : _keys.key]) {
      var _keys2;
      setLatestNotice(dictRef.current[(_keys2 = keys[keys.length - 1]) === null || _keys2 === void 0 ? void 0 : _keys2.key]);
    }
  }, [keys, stack]);
  return import_react3.default.createElement(CSSMotionList_default, _extends({
    key: placement,
    className: (0, import_classnames2.default)(prefixCls, "".concat(prefixCls, "-").concat(placement), ctxCls === null || ctxCls === void 0 ? void 0 : ctxCls.list, className, _defineProperty(_defineProperty({}, "".concat(prefixCls, "-stack"), !!stack), "".concat(prefixCls, "-stack-expanded"), expanded)),
    style,
    keys,
    motionAppear: true
  }, placementMotion, {
    onAllRemoved: function onAllRemoved() {
      onAllNoticeRemoved(placement);
    }
  }), function(_ref2, nodeRef) {
    var config = _ref2.config, motionClassName = _ref2.className, motionStyle = _ref2.style, motionIndex = _ref2.index;
    var _ref3 = config, key = _ref3.key, times = _ref3.times;
    var strKey = String(key);
    var _ref4 = config, configClassName = _ref4.className, configStyle = _ref4.style, configClassNames = _ref4.classNames, configStyles = _ref4.styles, restConfig = _objectWithoutProperties(_ref4, _excluded);
    var dataIndex = keys.findIndex(function(item) {
      return item.key === strKey;
    });
    var stackStyle = {};
    if (stack) {
      var index = keys.length - 1 - (dataIndex > -1 ? dataIndex : motionIndex - 1);
      var transformX = placement === "top" || placement === "bottom" ? "-50%" : "0";
      if (index > 0) {
        var _dictRef$current$strK, _dictRef$current$strK2, _dictRef$current$strK3;
        stackStyle.height = expanded ? (_dictRef$current$strK = dictRef.current[strKey]) === null || _dictRef$current$strK === void 0 ? void 0 : _dictRef$current$strK.offsetHeight : latestNotice === null || latestNotice === void 0 ? void 0 : latestNotice.offsetHeight;
        var verticalOffset = 0;
        for (var i = 0; i < index; i++) {
          var _dictRef$current$keys;
          verticalOffset += ((_dictRef$current$keys = dictRef.current[keys[keys.length - 1 - i].key]) === null || _dictRef$current$keys === void 0 ? void 0 : _dictRef$current$keys.offsetHeight) + gap;
        }
        var transformY = (expanded ? verticalOffset : index * offset) * (placement.startsWith("top") ? 1 : -1);
        var scaleX = !expanded && latestNotice !== null && latestNotice !== void 0 && latestNotice.offsetWidth && (_dictRef$current$strK2 = dictRef.current[strKey]) !== null && _dictRef$current$strK2 !== void 0 && _dictRef$current$strK2.offsetWidth ? ((latestNotice === null || latestNotice === void 0 ? void 0 : latestNotice.offsetWidth) - offset * 2 * (index < 3 ? index : 3)) / ((_dictRef$current$strK3 = dictRef.current[strKey]) === null || _dictRef$current$strK3 === void 0 ? void 0 : _dictRef$current$strK3.offsetWidth) : 1;
        stackStyle.transform = "translate3d(".concat(transformX, ", ").concat(transformY, "px, 0) scaleX(").concat(scaleX, ")");
      } else {
        stackStyle.transform = "translate3d(".concat(transformX, ", 0, 0)");
      }
    }
    return import_react3.default.createElement("div", {
      ref: nodeRef,
      className: (0, import_classnames2.default)("".concat(prefixCls, "-notice-wrapper"), motionClassName, configClassNames === null || configClassNames === void 0 ? void 0 : configClassNames.wrapper),
      style: _objectSpread2(_objectSpread2(_objectSpread2({}, motionStyle), stackStyle), configStyles === null || configStyles === void 0 ? void 0 : configStyles.wrapper),
      onMouseEnter: function onMouseEnter() {
        return setHoverKeys(function(prev) {
          return prev.includes(strKey) ? prev : [].concat(_toConsumableArray(prev), [strKey]);
        });
      },
      onMouseLeave: function onMouseLeave() {
        return setHoverKeys(function(prev) {
          return prev.filter(function(k) {
            return k !== strKey;
          });
        });
      }
    }, import_react3.default.createElement(Notice_default, _extends({}, restConfig, {
      ref: function ref(node) {
        if (dataIndex > -1) {
          dictRef.current[strKey] = node;
        } else {
          delete dictRef.current[strKey];
        }
      },
      prefixCls,
      classNames: configClassNames,
      styles: configStyles,
      className: (0, import_classnames2.default)(configClassName, ctxCls === null || ctxCls === void 0 ? void 0 : ctxCls.notice),
      style: configStyle,
      times,
      key,
      eventKey: key,
      onNoticeClose,
      hovering: stack && hoverKeys.length > 0
    })));
  });
};
if (true) {
  NoticeList.displayName = "NoticeList";
}
var NoticeList_default = NoticeList;

// node_modules/rc-notification/es/Notifications.js
var Notifications = React5.forwardRef(function(props, ref) {
  var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-notification" : _props$prefixCls, container = props.container, motion = props.motion, maxCount = props.maxCount, className = props.className, style = props.style, onAllRemoved = props.onAllRemoved, stack = props.stack, renderNotifications2 = props.renderNotifications;
  var _React$useState = React5.useState([]), _React$useState2 = _slicedToArray(_React$useState, 2), configList = _React$useState2[0], setConfigList = _React$useState2[1];
  var onNoticeClose = function onNoticeClose2(key) {
    var _config$onClose;
    var config = configList.find(function(item) {
      return item.key === key;
    });
    config === null || config === void 0 || (_config$onClose = config.onClose) === null || _config$onClose === void 0 || _config$onClose.call(config);
    setConfigList(function(list) {
      return list.filter(function(item) {
        return item.key !== key;
      });
    });
  };
  React5.useImperativeHandle(ref, function() {
    return {
      open: function open2(config) {
        setConfigList(function(list) {
          var clone = _toConsumableArray(list);
          var index = clone.findIndex(function(item) {
            return item.key === config.key;
          });
          var innerConfig = _objectSpread2({}, config);
          if (index >= 0) {
            var _list$index;
            innerConfig.times = (((_list$index = list[index]) === null || _list$index === void 0 ? void 0 : _list$index.times) || 0) + 1;
            clone[index] = innerConfig;
          } else {
            innerConfig.times = 0;
            clone.push(innerConfig);
          }
          if (maxCount > 0 && clone.length > maxCount) {
            clone = clone.slice(-maxCount);
          }
          return clone;
        });
      },
      close: function close(key) {
        onNoticeClose(key);
      },
      destroy: function destroy2() {
        setConfigList([]);
      }
    };
  });
  var _React$useState3 = React5.useState({}), _React$useState4 = _slicedToArray(_React$useState3, 2), placements = _React$useState4[0], setPlacements = _React$useState4[1];
  React5.useEffect(function() {
    var nextPlacements = {};
    configList.forEach(function(config) {
      var _config$placement = config.placement, placement = _config$placement === void 0 ? "topRight" : _config$placement;
      if (placement) {
        nextPlacements[placement] = nextPlacements[placement] || [];
        nextPlacements[placement].push(config);
      }
    });
    Object.keys(placements).forEach(function(placement) {
      nextPlacements[placement] = nextPlacements[placement] || [];
    });
    setPlacements(nextPlacements);
  }, [configList]);
  var onAllNoticeRemoved = function onAllNoticeRemoved2(placement) {
    setPlacements(function(originPlacements) {
      var clone = _objectSpread2({}, originPlacements);
      var list = clone[placement] || [];
      if (!list.length) {
        delete clone[placement];
      }
      return clone;
    });
  };
  var emptyRef = React5.useRef(false);
  React5.useEffect(function() {
    if (Object.keys(placements).length > 0) {
      emptyRef.current = true;
    } else if (emptyRef.current) {
      onAllRemoved === null || onAllRemoved === void 0 || onAllRemoved();
      emptyRef.current = false;
    }
  }, [placements]);
  if (!container) {
    return null;
  }
  var placementList = Object.keys(placements);
  return (0, import_react_dom.createPortal)(React5.createElement(React5.Fragment, null, placementList.map(function(placement) {
    var placementConfigList = placements[placement];
    var list = React5.createElement(NoticeList_default, {
      key: placement,
      configList: placementConfigList,
      placement,
      prefixCls,
      className: className === null || className === void 0 ? void 0 : className(placement),
      style: style === null || style === void 0 ? void 0 : style(placement),
      motion,
      onNoticeClose,
      onAllNoticeRemoved,
      stack
    });
    return renderNotifications2 ? renderNotifications2(list, {
      prefixCls,
      key: placement
    }) : list;
  })), container);
});
if (true) {
  Notifications.displayName = "Notifications";
}
var Notifications_default = Notifications;

// node_modules/rc-notification/es/hooks/useNotification.js
var _excluded2 = ["getContainer", "motion", "prefixCls", "maxCount", "className", "style", "onAllRemoved", "stack", "renderNotifications"];
var defaultGetContainer = function defaultGetContainer2() {
  return document.body;
};
var uniqueKey = 0;
function mergeConfig() {
  var clone = {};
  for (var _len = arguments.length, objList = new Array(_len), _key = 0; _key < _len; _key++) {
    objList[_key] = arguments[_key];
  }
  objList.forEach(function(obj) {
    if (obj) {
      Object.keys(obj).forEach(function(key) {
        var val = obj[key];
        if (val !== void 0) {
          clone[key] = val;
        }
      });
    }
  });
  return clone;
}
function useNotification() {
  var rootConfig = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var _rootConfig$getContai = rootConfig.getContainer, getContainer = _rootConfig$getContai === void 0 ? defaultGetContainer : _rootConfig$getContai, motion = rootConfig.motion, prefixCls = rootConfig.prefixCls, maxCount = rootConfig.maxCount, className = rootConfig.className, style = rootConfig.style, onAllRemoved = rootConfig.onAllRemoved, stack = rootConfig.stack, renderNotifications2 = rootConfig.renderNotifications, shareConfig = _objectWithoutProperties(rootConfig, _excluded2);
  var _React$useState = React6.useState(), _React$useState2 = _slicedToArray(_React$useState, 2), container = _React$useState2[0], setContainer = _React$useState2[1];
  var notificationsRef = React6.useRef();
  var contextHolder = React6.createElement(Notifications_default, {
    container,
    ref: notificationsRef,
    prefixCls,
    motion,
    maxCount,
    className,
    style,
    onAllRemoved,
    stack,
    renderNotifications: renderNotifications2
  });
  var _React$useState3 = React6.useState([]), _React$useState4 = _slicedToArray(_React$useState3, 2), taskQueue2 = _React$useState4[0], setTaskQueue = _React$useState4[1];
  var open2 = useEvent(function(config) {
    var mergedConfig = mergeConfig(shareConfig, config);
    if (mergedConfig.key === null || mergedConfig.key === void 0) {
      mergedConfig.key = "rc-notification-".concat(uniqueKey);
      uniqueKey += 1;
    }
    setTaskQueue(function(queue) {
      return [].concat(_toConsumableArray(queue), [{
        type: "open",
        config: mergedConfig
      }]);
    });
  });
  var api = React6.useMemo(function() {
    return {
      open: open2,
      close: function close(key) {
        setTaskQueue(function(queue) {
          return [].concat(_toConsumableArray(queue), [{
            type: "close",
            key
          }]);
        });
      },
      destroy: function destroy2() {
        setTaskQueue(function(queue) {
          return [].concat(_toConsumableArray(queue), [{
            type: "destroy"
          }]);
        });
      }
    };
  }, []);
  React6.useEffect(function() {
    setContainer(getContainer());
  });
  React6.useEffect(function() {
    if (notificationsRef.current && taskQueue2.length) {
      taskQueue2.forEach(function(task) {
        switch (task.type) {
          case "open":
            notificationsRef.current.open(task.config);
            break;
          case "close":
            notificationsRef.current.close(task.key);
            break;
          case "destroy":
            notificationsRef.current.destroy();
            break;
        }
      });
      var oriTaskQueue;
      var tgtTaskQueue;
      setTaskQueue(function(oriQueue) {
        if (oriTaskQueue !== oriQueue || !tgtTaskQueue) {
          oriTaskQueue = oriQueue;
          tgtTaskQueue = oriQueue.filter(function(task) {
            return !taskQueue2.includes(task);
          });
        }
        return tgtTaskQueue;
      });
    }
  }, [taskQueue2]);
  return [api, contextHolder];
}

// node_modules/antd/es/message/style/index.js
var genMessageStyle = (token) => {
  const {
    componentCls,
    iconCls,
    boxShadow,
    colorText,
    colorSuccess,
    colorError,
    colorWarning,
    colorInfo,
    fontSizeLG,
    motionEaseInOutCirc,
    motionDurationSlow,
    marginXS,
    paddingXS,
    borderRadiusLG,
    zIndexPopup,
    // Custom token
    contentPadding,
    contentBg
  } = token;
  const noticeCls = `${componentCls}-notice`;
  const messageMoveIn = new Keyframes_default("MessageMoveIn", {
    "0%": {
      padding: 0,
      transform: "translateY(-100%)",
      opacity: 0
    },
    "100%": {
      padding: paddingXS,
      transform: "translateY(0)",
      opacity: 1
    }
  });
  const messageMoveOut = new Keyframes_default("MessageMoveOut", {
    "0%": {
      maxHeight: token.height,
      padding: paddingXS,
      opacity: 1
    },
    "100%": {
      maxHeight: 0,
      padding: 0,
      opacity: 0
    }
  });
  const noticeStyle = {
    padding: paddingXS,
    textAlign: "center",
    [`${componentCls}-custom-content`]: {
      display: "flex",
      alignItems: "center"
    },
    [`${componentCls}-custom-content > ${iconCls}`]: {
      marginInlineEnd: marginXS,
      // affected by ltr or rtl
      fontSize: fontSizeLG
    },
    [`${noticeCls}-content`]: {
      display: "inline-block",
      padding: contentPadding,
      background: contentBg,
      borderRadius: borderRadiusLG,
      boxShadow,
      pointerEvents: "all"
    },
    [`${componentCls}-success > ${iconCls}`]: {
      color: colorSuccess
    },
    [`${componentCls}-error > ${iconCls}`]: {
      color: colorError
    },
    [`${componentCls}-warning > ${iconCls}`]: {
      color: colorWarning
    },
    [`${componentCls}-info > ${iconCls},
      ${componentCls}-loading > ${iconCls}`]: {
      color: colorInfo
    }
  };
  return [
    // ============================ Holder ============================
    {
      [componentCls]: Object.assign(Object.assign({}, resetComponent(token)), {
        color: colorText,
        position: "fixed",
        top: marginXS,
        width: "100%",
        pointerEvents: "none",
        zIndex: zIndexPopup,
        [`${componentCls}-move-up`]: {
          animationFillMode: "forwards"
        },
        [`
        ${componentCls}-move-up-appear,
        ${componentCls}-move-up-enter
      `]: {
          animationName: messageMoveIn,
          animationDuration: motionDurationSlow,
          animationPlayState: "paused",
          animationTimingFunction: motionEaseInOutCirc
        },
        [`
        ${componentCls}-move-up-appear${componentCls}-move-up-appear-active,
        ${componentCls}-move-up-enter${componentCls}-move-up-enter-active
      `]: {
          animationPlayState: "running"
        },
        [`${componentCls}-move-up-leave`]: {
          animationName: messageMoveOut,
          animationDuration: motionDurationSlow,
          animationPlayState: "paused",
          animationTimingFunction: motionEaseInOutCirc
        },
        [`${componentCls}-move-up-leave${componentCls}-move-up-leave-active`]: {
          animationPlayState: "running"
        },
        "&-rtl": {
          direction: "rtl",
          span: {
            direction: "rtl"
          }
        }
      })
    },
    // ============================ Notice ============================
    {
      [componentCls]: {
        [`${noticeCls}-wrapper`]: Object.assign({}, noticeStyle)
      }
    },
    // ============================= Pure =============================
    {
      [`${componentCls}-notice-pure-panel`]: Object.assign(Object.assign({}, noticeStyle), {
        padding: 0,
        textAlign: "start"
      })
    }
  ];
};
var prepareComponentToken = (token) => ({
  zIndexPopup: token.zIndexPopupBase + CONTAINER_MAX_OFFSET + 10,
  contentBg: token.colorBgElevated,
  contentPadding: `${(token.controlHeightLG - token.fontSize * token.lineHeight) / 2}px ${token.paddingSM}px`
});
var style_default = genStyleHooks("Message", (token) => {
  const combinedToken = merge(token, {
    height: 150
  });
  return genMessageStyle(combinedToken);
}, prepareComponentToken);

// node_modules/antd/es/message/PurePanel.js
var __rest = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var TypeIcon = {
  info: React7.createElement(InfoCircleFilled_default, null),
  success: React7.createElement(CheckCircleFilled_default, null),
  error: React7.createElement(CloseCircleFilled_default, null),
  warning: React7.createElement(ExclamationCircleFilled_default, null),
  loading: React7.createElement(LoadingOutlined_default, null)
};
var PureContent = ({
  prefixCls,
  type,
  icon,
  children
}) => React7.createElement("div", {
  className: (0, import_classnames3.default)(`${prefixCls}-custom-content`, `${prefixCls}-${type}`)
}, icon || TypeIcon[type], React7.createElement("span", null, children));
var PurePanel = (props) => {
  const {
    prefixCls: staticPrefixCls,
    className,
    type,
    icon,
    content
  } = props, restProps = __rest(props, ["prefixCls", "className", "type", "icon", "content"]);
  const {
    getPrefixCls
  } = React7.useContext(ConfigContext);
  const prefixCls = staticPrefixCls || getPrefixCls("message");
  const rootCls = useCSSVarCls_default(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default(prefixCls, rootCls);
  return wrapCSSVar(React7.createElement(Notice_default, Object.assign({}, restProps, {
    prefixCls,
    className: (0, import_classnames3.default)(className, hashId, `${prefixCls}-notice-pure-panel`, cssVarCls, rootCls),
    eventKey: "pure",
    duration: null,
    content: React7.createElement(PureContent, {
      prefixCls,
      type,
      icon
    }, content)
  })));
};
var PurePanel_default = PurePanel;

// node_modules/antd/es/message/useMessage.js
var React8 = __toESM(require_react());
var import_classnames4 = __toESM(require_classnames());

// node_modules/antd/es/message/util.js
function getMotion(prefixCls, transitionName) {
  return {
    motionName: transitionName !== null && transitionName !== void 0 ? transitionName : `${prefixCls}-move-up`
  };
}
function wrapPromiseFn(openFn) {
  let closeFn;
  const closePromise = new Promise((resolve) => {
    closeFn = openFn(() => {
      resolve(true);
    });
  });
  const result = () => {
    closeFn === null || closeFn === void 0 ? void 0 : closeFn();
  };
  result.then = (filled, rejected) => closePromise.then(filled, rejected);
  result.promise = closePromise;
  return result;
}

// node_modules/antd/es/message/useMessage.js
var __rest2 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var DEFAULT_OFFSET2 = 8;
var DEFAULT_DURATION = 3;
var Wrapper = ({
  children,
  prefixCls
}) => {
  const rootCls = useCSSVarCls_default(prefixCls);
  const [wrapCSSVar, hashId, cssVarCls] = style_default(prefixCls, rootCls);
  return wrapCSSVar(React8.createElement(NotificationProvider_default, {
    classNames: {
      list: (0, import_classnames4.default)(hashId, cssVarCls, rootCls)
    }
  }, children));
};
var renderNotifications = (node, {
  prefixCls,
  key
}) => React8.createElement(Wrapper, {
  prefixCls,
  key
}, node);
var Holder = React8.forwardRef((props, ref) => {
  const {
    top,
    prefixCls: staticPrefixCls,
    getContainer: staticGetContainer,
    maxCount,
    duration = DEFAULT_DURATION,
    rtl,
    transitionName,
    onAllRemoved
  } = props;
  const {
    getPrefixCls,
    getPopupContainer,
    message: message2,
    direction
  } = React8.useContext(ConfigContext);
  const prefixCls = staticPrefixCls || getPrefixCls("message");
  const getStyle = () => ({
    left: "50%",
    transform: "translateX(-50%)",
    top: top !== null && top !== void 0 ? top : DEFAULT_OFFSET2
  });
  const getClassName = () => (0, import_classnames4.default)({
    [`${prefixCls}-rtl`]: rtl !== null && rtl !== void 0 ? rtl : direction === "rtl"
  });
  const getNotificationMotion = () => getMotion(prefixCls, transitionName);
  const mergedCloseIcon = React8.createElement("span", {
    className: `${prefixCls}-close-x`
  }, React8.createElement(CloseOutlined_default, {
    className: `${prefixCls}-close-icon`
  }));
  const [api, holder] = useNotification({
    prefixCls,
    style: getStyle,
    className: getClassName,
    motion: getNotificationMotion,
    closable: false,
    closeIcon: mergedCloseIcon,
    duration,
    getContainer: () => (staticGetContainer === null || staticGetContainer === void 0 ? void 0 : staticGetContainer()) || (getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer()) || document.body,
    maxCount,
    onAllRemoved,
    renderNotifications
  });
  React8.useImperativeHandle(ref, () => Object.assign(Object.assign({}, api), {
    prefixCls,
    message: message2
  }));
  return holder;
});
var keyIndex = 0;
function useInternalMessage(messageConfig) {
  const holderRef = React8.useRef(null);
  const warning = devUseWarning("Message");
  const wrapAPI = React8.useMemo(() => {
    const close = (key) => {
      var _a;
      (_a = holderRef.current) === null || _a === void 0 ? void 0 : _a.close(key);
    };
    const open2 = (config) => {
      if (!holderRef.current) {
        true ? warning(false, "usage", "You are calling notice in render which will break in React 18 concurrent mode. Please trigger in effect instead.") : void 0;
        const fakeResult = () => {
        };
        fakeResult.then = () => {
        };
        return fakeResult;
      }
      const {
        open: originOpen,
        prefixCls,
        message: message2
      } = holderRef.current;
      const noticePrefixCls = `${prefixCls}-notice`;
      const {
        content,
        icon,
        type,
        key,
        className,
        style,
        onClose
      } = config, restConfig = __rest2(config, ["content", "icon", "type", "key", "className", "style", "onClose"]);
      let mergedKey = key;
      if (mergedKey === void 0 || mergedKey === null) {
        keyIndex += 1;
        mergedKey = `antd-message-${keyIndex}`;
      }
      return wrapPromiseFn((resolve) => {
        originOpen(Object.assign(Object.assign({}, restConfig), {
          key: mergedKey,
          content: React8.createElement(PureContent, {
            prefixCls,
            type,
            icon
          }, content),
          placement: "top",
          className: (0, import_classnames4.default)(type && `${noticePrefixCls}-${type}`, className, message2 === null || message2 === void 0 ? void 0 : message2.className),
          style: Object.assign(Object.assign({}, message2 === null || message2 === void 0 ? void 0 : message2.style), style),
          onClose: () => {
            onClose === null || onClose === void 0 ? void 0 : onClose();
            resolve();
          }
        }));
        return () => {
          close(mergedKey);
        };
      });
    };
    const destroy2 = (key) => {
      var _a;
      if (key !== void 0) {
        close(key);
      } else {
        (_a = holderRef.current) === null || _a === void 0 ? void 0 : _a.destroy();
      }
    };
    const clone = {
      open: open2,
      destroy: destroy2
    };
    const keys = ["info", "success", "warning", "error", "loading"];
    keys.forEach((type) => {
      const typeOpen2 = (jointContent, duration, onClose) => {
        let config;
        if (jointContent && typeof jointContent === "object" && "content" in jointContent) {
          config = jointContent;
        } else {
          config = {
            content: jointContent
          };
        }
        let mergedDuration;
        let mergedOnClose;
        if (typeof duration === "function") {
          mergedOnClose = duration;
        } else {
          mergedDuration = duration;
          mergedOnClose = onClose;
        }
        const mergedConfig = Object.assign(Object.assign({
          onClose: mergedOnClose,
          duration: mergedDuration
        }, config), {
          type
        });
        return open2(mergedConfig);
      };
      clone[type] = typeOpen2;
    });
    return clone;
  }, []);
  return [wrapAPI, React8.createElement(Holder, Object.assign({
    key: "message-holder"
  }, messageConfig, {
    ref: holderRef
  }))];
}
function useMessage(messageConfig) {
  return useInternalMessage(messageConfig);
}

// node_modules/antd/es/message/index.js
var message = null;
var act = (callback) => callback();
var taskQueue = [];
var defaultGlobalConfig = {};
function getGlobalContext() {
  const {
    getContainer,
    duration,
    rtl,
    maxCount,
    top
  } = defaultGlobalConfig;
  const mergedContainer = (getContainer === null || getContainer === void 0 ? void 0 : getContainer()) || document.body;
  return {
    getContainer: () => mergedContainer,
    duration,
    rtl,
    maxCount,
    top
  };
}
var GlobalHolder = import_react4.default.forwardRef((props, ref) => {
  const {
    messageConfig,
    sync
  } = props;
  const {
    getPrefixCls
  } = (0, import_react4.useContext)(ConfigContext);
  const prefixCls = defaultGlobalConfig.prefixCls || getPrefixCls("message");
  const appConfig = (0, import_react4.useContext)(AppConfigContext);
  const [api, holder] = useInternalMessage(Object.assign(Object.assign(Object.assign({}, messageConfig), {
    prefixCls
  }), appConfig.message));
  import_react4.default.useImperativeHandle(ref, () => {
    const instance = Object.assign({}, api);
    Object.keys(instance).forEach((method) => {
      instance[method] = (...args) => {
        sync();
        return api[method].apply(api, args);
      };
    });
    return {
      instance,
      sync
    };
  });
  return holder;
});
var GlobalHolderWrapper = import_react4.default.forwardRef((_, ref) => {
  const [messageConfig, setMessageConfig] = import_react4.default.useState(getGlobalContext);
  const sync = () => {
    setMessageConfig(getGlobalContext);
  };
  import_react4.default.useEffect(sync, []);
  const global = globalConfig();
  const rootPrefixCls = global.getRootPrefixCls();
  const rootIconPrefixCls = global.getIconPrefixCls();
  const theme = global.getTheme();
  const dom = import_react4.default.createElement(GlobalHolder, {
    ref,
    sync,
    messageConfig
  });
  return import_react4.default.createElement(config_provider_default, {
    prefixCls: rootPrefixCls,
    iconPrefixCls: rootIconPrefixCls,
    theme
  }, global.holderRender ? global.holderRender(dom) : dom);
});
var flushMessageQueue = () => {
  if (!message) {
    const holderFragment = document.createDocumentFragment();
    const newMessage = {
      fragment: holderFragment
    };
    message = newMessage;
    act(() => {
      const reactRender = unstableSetRender();
      reactRender(import_react4.default.createElement(GlobalHolderWrapper, {
        ref: (node) => {
          const {
            instance,
            sync
          } = node || {};
          Promise.resolve().then(() => {
            if (!newMessage.instance && instance) {
              newMessage.instance = instance;
              newMessage.sync = sync;
              flushMessageQueue();
            }
          });
        }
      }), holderFragment);
    });
    return;
  }
  if (!message.instance) {
    return;
  }
  taskQueue.forEach((task) => {
    const {
      type,
      skipped
    } = task;
    if (!skipped) {
      switch (type) {
        case "open": {
          act(() => {
            const closeFn = message.instance.open(Object.assign(Object.assign({}, defaultGlobalConfig), task.config));
            closeFn === null || closeFn === void 0 ? void 0 : closeFn.then(task.resolve);
            task.setCloseFn(closeFn);
          });
          break;
        }
        case "destroy":
          act(() => {
            message === null || message === void 0 ? void 0 : message.instance.destroy(task.key);
          });
          break;
        default: {
          act(() => {
            var _message$instance;
            const closeFn = (_message$instance = message.instance)[type].apply(_message$instance, _toConsumableArray(task.args));
            closeFn === null || closeFn === void 0 ? void 0 : closeFn.then(task.resolve);
            task.setCloseFn(closeFn);
          });
        }
      }
    }
  });
  taskQueue = [];
};
function setMessageGlobalConfig(config) {
  defaultGlobalConfig = Object.assign(Object.assign({}, defaultGlobalConfig), config);
  act(() => {
    var _a;
    (_a = message === null || message === void 0 ? void 0 : message.sync) === null || _a === void 0 ? void 0 : _a.call(message);
  });
}
function open(config) {
  const result = wrapPromiseFn((resolve) => {
    let closeFn;
    const task = {
      type: "open",
      config,
      resolve,
      setCloseFn: (fn) => {
        closeFn = fn;
      }
    };
    taskQueue.push(task);
    return () => {
      if (closeFn) {
        act(() => {
          closeFn();
        });
      } else {
        task.skipped = true;
      }
    };
  });
  flushMessageQueue();
  return result;
}
function typeOpen(type, args) {
  const global = globalConfig();
  if (!global.holderRender) {
    warnContext("message");
  }
  const result = wrapPromiseFn((resolve) => {
    let closeFn;
    const task = {
      type,
      args,
      resolve,
      setCloseFn: (fn) => {
        closeFn = fn;
      }
    };
    taskQueue.push(task);
    return () => {
      if (closeFn) {
        act(() => {
          closeFn();
        });
      } else {
        task.skipped = true;
      }
    };
  });
  flushMessageQueue();
  return result;
}
var destroy = (key) => {
  taskQueue.push({
    type: "destroy",
    key
  });
  flushMessageQueue();
};
var methods = ["success", "info", "warning", "error", "loading"];
var baseStaticMethods = {
  open,
  destroy,
  config: setMessageGlobalConfig,
  useMessage,
  _InternalPanelDoNotUseOrYouWillBeFired: PurePanel_default
};
var staticMethods = baseStaticMethods;
methods.forEach((type) => {
  staticMethods[type] = (...args) => typeOpen(type, args);
});
var noop = () => {
};
var _actWrapper = noop;
if (false) {
  _actWrapper = (wrapper) => {
    act = wrapper;
  };
}
var actWrapper = _actWrapper;
var _actDestroy = noop;
if (false) {
  _actDestroy = () => {
    message = null;
  };
}
var actDestroy = _actDestroy;
var message_default = staticMethods;

export {
  Notice_default,
  NotificationProvider_default,
  useNotification,
  useMessage,
  AppConfigContext,
  context_default,
  actWrapper,
  actDestroy,
  message_default
};
//# sourceMappingURL=chunk-4SF3LPM5.js.map
